import { ref as h, defineComponent as C, provide as W, onMounted as j, watch as v, computed as A, openBlock as g, createElementBlock as y, normalizeStyle as D, Fragment as K, renderList as I, createBlock as w, unref as b, createCommentVNode as L, renderSlot as _, toRaw as F, inject as O, onBeforeUnmount as P, withCtx as Z } from "vue";
const M = h(!1), Q = (p, u) => {
  const i = document.createElement("script"), e = u != null && u.length > 0 ? `&libraries=${u.join(",")}` : "";
  i.id = "kakao-map-api-script", i.src = `//dapi.kakao.com/v2/maps/sdk.js?appkey=${p}&autoload=false${e}`, document.body.appendChild(i), i.onload = () => {
    kakao.maps.load(() => {
      M.value = !0;
    });
  };
}, T = /* @__PURE__ */ C({
  __name: "KakaoMap",
  props: {
    width: { default: "40rem" },
    height: { default: "30rem" },
    markerList: {},
    infoWindowList: {},
    markerCluster: {},
    lat: {},
    lng: {},
    level: { default: 3 },
    mapTypeId: {},
    draggable: { type: Boolean, default: !0 },
    scrollwheel: { type: Boolean, default: !0 },
    disableDoubleClick: { type: Boolean, default: !1 },
    disableDoubleClickZoom: { type: Boolean, default: !1 },
    projectionId: { default: "kakao.maps.ProjectionId.WCONG" },
    tileAnimation: { type: Boolean, default: !0 },
    keyboardShortcuts: { type: [Boolean, Object] }
  },
  emits: ["onLoadKakaoMap", "onLoadKakaoMapMarkerCluster"],
  setup(p, { emit: u }) {
    const i = p, e = u, a = h(null), k = h();
    W("mapRef", k);
    const r = () => {
      const o = {
        center: new kakao.maps.LatLng(i.lat, i.lng),
        ...i
      };
      a.value !== null && (k.value = new window.kakao.maps.Map(a.value, o), e("onLoadKakaoMap", k.value));
    }, m = h(), t = (o) => {
      if (o.markers === void 0)
        throw new Error("MarkerList가 없습니다.");
      if (k.value !== null) {
        const d = h([]);
        o.markers.forEach((n) => {
          var c;
          const s = new kakao.maps.Marker({
            position: new kakao.maps.LatLng(n.lat, n.lng),
            image: n.image ?? void 0,
            title: n.title ?? void 0,
            draggable: typeof n.draggable == "boolean" ? n.draggable : !1,
            clickable: typeof n.clickable == "boolean" ? n.clickable : !1,
            zIndex: typeof n.zIndex == "number" ? n.zIndex : 0,
            opacity: n.opacity ?? 1,
            altitude: n.altitude ?? 0,
            range: n.range ?? void 0
          });
          (c = d.value) == null || c.push(s);
        }), m.value = new kakao.maps.MarkerClusterer({
          map: F(k.value),
          ...o,
          markers: d.value
        }), e("onLoadKakaoMapMarkerCluster", m.value);
      }
    };
    j(() => {
      M.value && (r(), i.markerCluster !== void 0 && t(i.markerCluster));
    }), v(
      () => M.value,
      (o) => {
        o && (r(), i.markerCluster !== void 0 && t(i.markerCluster));
      }
    );
    const l = A(() => ({
      width: isFinite(+i.width) ? i.width + "px" : i.width,
      height: isFinite(+i.height) ? i.height + "px" : i.height
    }));
    return v([() => i.lat, () => i.lng], ([o, d]) => {
      var n;
      (n = k.value) == null || n.panTo(new kakao.maps.LatLng(o, d));
    }), v(
      () => i.draggable,
      (o) => {
        var d, n;
        o === void 0 || o ? (d = k.value) == null || d.setDraggable(!0) : (n = k.value) == null || n.setDraggable(!1);
      }
    ), v(
      () => i.level,
      (o) => {
        var d, n;
        o === void 0 ? (d = k.value) == null || d.setLevel(3) : (n = k.value) == null || n.setLevel(o);
      }
    ), v(
      () => i.mapTypeId,
      (o) => {
        var d, n;
        o === void 0 ? (d = k.value) == null || d.setMapTypeId(3) : (n = k.value) == null || n.setMapTypeId(o);
      }
    ), v(
      () => i.scrollwheel,
      (o) => {
        var d, n;
        o === void 0 ? (d = k.value) == null || d.setZoomable(!0) : (n = k.value) == null || n.setZoomable(o);
      }
    ), v(
      () => i.projectionId,
      (o) => {
        var d, n;
        o === void 0 ? (d = k.value) == null || d.setProjectionId(kakao.maps.ProjectionId.WCONG) : (n = k.value) == null || n.setProjectionId(o);
      }
    ), v(
      () => i.keyboardShortcuts,
      (o) => {
        var d, n;
        o === void 0 ? (d = k.value) == null || d.setKeyboardShortcuts(!1) : typeof o == "boolean" && ((n = k.value) == null || n.setKeyboardShortcuts(o));
      }
    ), (o, d) => (g(), y("div", {
      ref_key: "kakaoMapRef",
      ref: a,
      style: D(l.value)
    }, [
      i.markerList && i.markerCluster === void 0 ? (g(!0), y(K, { key: 0 }, I(i.markerList, (n, s) => (g(), w(b($), {
        key: n.key === void 0 ? s : n.key,
        lat: n.lat,
        lng: n.lng,
        "info-window": n == null ? void 0 : n.infoWindow,
        draggable: n.draggable,
        image: n.image,
        order: n.order,
        "order-bottom-margin": n.orderBottomMargin
      }, null, 8, ["lat", "lng", "info-window", "draggable", "image", "order", "order-bottom-margin"]))), 128)) : L("", !0),
      i.infoWindowList && i.markerCluster === void 0 ? (g(!0), y(K, { key: 1 }, I(i.infoWindowList, (n, s) => (g(), w(b(B), {
        key: n.key === void 0 ? s : n.key,
        lat: n.lat,
        lng: n.lng,
        content: n.content,
        visible: n.visible
      }, null, 8, ["lat", "lng", "content", "visible"]))), 128)) : L("", !0),
      _(o.$slots, "default")
    ], 4));
  }
}), N = {
  imageSrc: "https://t1.daumcdn.net/mapjsapi/images/2x/marker.png",
  imageWidth: 29,
  imageHeight: 42,
  imageOption: {}
}, $ = /* @__PURE__ */ C({
  __name: "KakaoMapMarker",
  props: {
    lat: {},
    lng: {},
    infoWindow: {},
    visible: { type: Boolean },
    image: {},
    title: {},
    draggable: { type: Boolean },
    clickable: { type: Boolean },
    zIndex: {},
    opacity: {},
    altitude: {},
    range: {},
    order: {},
    orderBottomMargin: {}
  },
  emits: [
    "onLoadKakaoMapMarker",
    "onClickKakaoMapMarker",
    "dragEndKakaoMapMarker",
    "mouseOverKakaoMapMarker",
    "mouseOutKakaoMapMarker",
    "deleteKakaoMapMarker"
  ],
  setup(p, { emit: u }) {
    const i = u, e = p, a = h(), k = O("mapRef"), r = (s) => {
      if (s != null) {
        if (s.imageSrc === void 0)
          throw new Error("이미지 경로가 존재하지 않습니다.");
      } else
        s = N;
      const c = new Image();
      c.src = s.imageSrc;
      const f = new kakao.maps.MarkerImage(
        s.imageSrc,
        new kakao.maps.Size(s.imageWidth ?? c.width, s.imageHeight ?? c.height),
        s.imageOption
      );
      a.value !== void 0 && a.value.setImage(f);
    }, m = (s) => {
      if (e.lat === void 0 || e.lng === void 0)
        throw new Error("marker의 위치가 없습니다.");
      const c = new kakao.maps.LatLng(e.lat, e.lng);
      a.value = new kakao.maps.Marker({
        position: c,
        title: e.title,
        draggable: e.draggable,
        clickable: e.clickable,
        zIndex: e.zIndex,
        opacity: e.opacity,
        altitude: e.altitude,
        range: e.range
      }), r(e.image), i("onLoadKakaoMapMarker", a.value), a.value.setMap(s), t(a.value), o(a.value), d(a.value), l(s, a.value);
    }, t = (s) => {
      kakao.maps.event.addListener(s, "click", () => {
        i("onClickKakaoMapMarker");
      });
    }, l = (s, c) => {
      kakao.maps.event.addListener(c, "dragend", function(f) {
        i("dragEndKakaoMapMarker", c);
      });
    }, o = (s) => {
      kakao.maps.event.addListener(s, "mouseover", () => {
        i("mouseOverKakaoMapMarker");
      });
    }, d = (s) => {
      kakao.maps.event.addListener(s, "mouseout", () => {
        i("mouseOutKakaoMapMarker");
      });
    }, n = (s) => `<div style="position:relative; bottom:${e.orderBottomMargin}">
        ${s}
      </div>`;
    return P(() => {
      var s;
      i("deleteKakaoMapMarker", a), (s = a.value) == null || s.setMap(null);
    }), v(
      [() => M.value, () => k, () => k == null ? void 0 : k.value],
      ([s, c, f]) => {
        s && c !== void 0 && f !== void 0 && m(f);
      },
      { immediate: !0 }
    ), v([() => e.lat, () => e.lng], ([s, c]) => {
      var f;
      M.value && ((f = a.value) == null || f.setPosition(new kakao.maps.LatLng(s, c)));
    }), v([() => e.image], () => {
      r(e.image);
    }), v(
      () => e.title,
      (s) => {
        var c;
        s !== void 0 && ((c = a.value) == null || c.setTitle(s));
      }
    ), v(
      () => e.draggable,
      (s) => {
        var c;
        (c = a.value) == null || c.setDraggable(s !== void 0 && s);
      }
    ), v(
      () => e.clickable,
      (s) => {
        var c;
        (c = a.value) == null || c.setDraggable(s !== void 0 && s);
      }
    ), v(
      () => e.zIndex,
      (s) => {
        var c;
        s !== void 0 && isFinite(s) && ((c = a.value) == null || c.setZIndex(Number(s)));
      }
    ), v(
      () => e.opacity,
      (s) => {
        var c, f;
        s !== void 0 && isFinite(s) ? (c = a.value) == null || c.setOpacity(Number(s)) : (f = a.value) == null || f.setOpacity(1);
      }
    ), (s, c) => {
      var f, z, S;
      return g(), y("div", null, [
        s.$slots.infoWindow ? (g(), w(b(B), {
          key: 0,
          marker: a.value,
          lat: e.lat,
          lng: e.lng,
          visible: (f = e == null ? void 0 : e.infoWindow) == null ? void 0 : f.visible
        }, {
          default: Z(() => [
            _(s.$slots, "infoWindow")
          ]),
          _: 3
        }, 8, ["marker", "lat", "lng", "visible"])) : e.infoWindow ? (g(), w(b(B), {
          key: 1,
          marker: a.value,
          lat: e.lat,
          lng: e.lng,
          content: (z = e == null ? void 0 : e.infoWindow) == null ? void 0 : z.content,
          visible: (S = e == null ? void 0 : e.infoWindow) == null ? void 0 : S.visible
        }, null, 8, ["marker", "lat", "lng", "content", "visible"])) : L("", !0),
        e.order ? (g(), w(b(x), {
          key: 2,
          lat: e.lat,
          lng: e.lng,
          "y-anchor": 0,
          content: n(e.order)
        }, null, 8, ["lat", "lng", "content"])) : L("", !0)
      ]);
    };
  }
}), G = { key: 0 }, B = /* @__PURE__ */ C({
  __name: "KakaoMapInfoWindow",
  props: {
    lat: {},
    lng: {},
    marker: {},
    content: {},
    disableAutoPan: { type: Boolean },
    removable: { type: Boolean, default: !1 },
    zIndex: {},
    altitude: {},
    range: { default: 500 },
    visible: { type: Boolean, default: !0 }
  },
  emits: ["onLoadKakaoMapInfoWindow"],
  setup(p, { emit: u }) {
    const i = u, e = p, a = h(), k = h(), r = O("mapRef"), m = (t) => {
      var o, d;
      if (e.lat === void 0 || e.lng === void 0)
        throw new Error("infoWindow의 위치가 없습니다.");
      const l = new kakao.maps.LatLng(e.lat, e.lng);
      a.value = new kakao.maps.InfoWindow({
        position: l,
        content: k.value ?? e.content ?? "",
        removable: e.removable,
        disableAutoPan: e.disableAutoPan,
        zIndex: e.zIndex,
        altitude: e.altitude,
        range: e.range
      }), e.visible && (i("onLoadKakaoMapInfoWindow", a.value), e.marker !== void 0 ? (o = a == null ? void 0 : a.value) == null || o.open(t, e.marker) : (d = a == null ? void 0 : a.value) == null || d.open(t));
    };
    return P(() => {
      (a == null ? void 0 : a.value) !== null && a.value !== void 0 && a.value.close();
    }), v(
      [() => M.value, () => r == null ? void 0 : r.value, () => M, () => r],
      ([t, l]) => {
        e.visible && t && l !== void 0 && l !== null && m(l);
      },
      { immediate: !0 }
    ), v(
      () => e.marker,
      (t) => {
        var l, o, d;
        !e.visible || (r == null ? void 0 : r.value) === void 0 || (a.value != null && ((l = a.value) == null || l.close()), t !== void 0 ? (o = a == null ? void 0 : a.value) == null || o.open(r == null ? void 0 : r.value, t) : (d = a == null ? void 0 : a.value) == null || d.open(r == null ? void 0 : r.value));
      },
      {
        immediate: !0
      }
    ), v(
      [() => k == null ? void 0 : k.value, () => k],
      ([t, l]) => {
        var o;
        t !== void 0 && ((o = a.value) == null || o.setContent(t));
      },
      { deep: !0 }
    ), v([() => e.lat, () => e.lng], ([t, l]) => {
      var o;
      (o = a.value) == null || o.setPosition(new kakao.maps.LatLng(t, l));
    }), v(
      () => e.content,
      (t) => {
        var l;
        (l = a.value) == null || l.setContent(t ?? "");
      }
    ), v(
      () => e.zIndex,
      (t) => {
        var l;
        (l = a.value) == null || l.setZIndex(t ?? 0);
      }
    ), v(
      () => e.altitude,
      (t) => {
        var l;
        (l = a.value) == null || l.setAltitude(t ?? 0);
      }
    ), v(
      () => e.range,
      (t) => {
        var l;
        (l = a.value) == null || l.setRange(t ?? 500);
      }
    ), v(
      () => e.visible,
      (t) => {
        t ? M != null && M.value && (r == null ? void 0 : r.value) !== void 0 && (r == null ? void 0 : r.value) !== null && m(r.value) : (a == null ? void 0 : a.value) !== null && a.value !== void 0 && a.value.close();
      }
    ), (t, l) => e.content && e.content.length > 0 || t.$slots.default ? (g(), y("div", G, [
      t.$slots.default ? (g(), y("div", {
        key: 0,
        ref_key: "contentSlot",
        ref: k
      }, [
        _(t.$slots, "default")
      ], 512)) : L("", !0)
    ])) : L("", !0);
  }
}), H = { key: 0 }, x = /* @__PURE__ */ C({
  __name: "KakaoMapCustomOverlay",
  props: {
    lat: {},
    lng: {},
    content: {},
    xAnchor: { default: 0.5 },
    yAnchor: { default: 0.5 },
    zIndex: {},
    clickable: { type: Boolean, default: !1 },
    visible: { type: Boolean, default: !0 }
  },
  emits: ["onLoadKakaoMapCustomOverlay"],
  setup(p, { emit: u }) {
    const i = u, e = p, a = h(), k = h(), r = O("mapRef"), m = (t) => {
      if (e.lat === void 0 || e.lng === void 0)
        throw new Error("KakaoMapCustomOverlay의 위치가 없습니다.");
      const l = new kakao.maps.LatLng(e.lat, e.lng);
      a.value = new kakao.maps.CustomOverlay({
        position: l,
        content: k.value ?? e.content ?? "",
        xAnchor: e.xAnchor,
        yAnchor: e.yAnchor,
        zIndex: e.zIndex,
        clickable: e.clickable
      }), e.visible && (a.value.setMap(t), i("onLoadKakaoMapCustomOverlay", a.value));
    };
    return P(() => {
      var t;
      a.value !== null && ((t = a.value) == null || t.setMap(null));
    }), v(
      [() => M.value, () => r == null ? void 0 : r.value, () => M, () => r],
      ([t, l]) => {
        e.visible && t && l !== void 0 && l !== null && m(l);
      },
      { immediate: !0 }
    ), v([() => e.lat, () => e.lng], ([t, l]) => {
      var o;
      (o = a.value) == null || o.setPosition(new kakao.maps.LatLng(t, l));
    }), v(
      () => e.content,
      (t) => {
        var l;
        (l = a.value) == null || l.setContent(t ?? "");
      }
    ), v(
      () => e.zIndex,
      (t) => {
        var l;
        (l = a.value) == null || l.setZIndex(t ?? 0);
      }
    ), v(
      () => e.visible,
      (t) => {
        var l;
        t ? M != null && M.value && (r == null ? void 0 : r.value) !== void 0 && (r == null ? void 0 : r.value) !== null && m(r.value) : (a == null ? void 0 : a.value) !== null && a.value !== void 0 && ((l = a.value) == null || l.setMap(null));
      }
    ), (t, l) => e.content && e.content.length > 0 || t.$slots.default ? (g(), y("div", H, [
      t.$slots.default ? (g(), y("div", {
        key: 0,
        ref_key: "contentSlot",
        ref: k
      }, [
        _(t.$slots, "default")
      ], 512)) : L("", !0)
    ])) : L("", !0);
  }
}), E = /* @__PURE__ */ C({
  __name: "KakaoMapPolyline",
  props: {
    latLngList: {},
    endArrow: { type: Boolean },
    strokeWeight: { default: 3 },
    strokeColor: { default: "#F10000" },
    strokeOpacity: { default: 0.6 },
    strokeStyle: { default: "solid" },
    zIndex: {}
  },
  setup(p) {
    const u = p, i = O("mapRef");
    let e = null;
    const a = A(() => u.latLngList.map((r) => new kakao.maps.LatLng(r.lat, r.lng))), k = (r) => {
      e = new kakao.maps.Polyline({
        path: a.value,
        endArrow: u.endArrow,
        strokeWeight: u.strokeWeight,
        strokeColor: u.strokeColor,
        strokeOpacity: u.strokeOpacity,
        strokeStyle: u.strokeStyle,
        zIndex: u.zIndex
      }), e.setMap(r);
    };
    return v(
      [() => M.value, () => i == null ? void 0 : i.value, () => M, () => i],
      ([r, m]) => {
        r && m !== void 0 && m !== null && k(m);
      },
      { immediate: !0 }
    ), v(
      () => u.latLngList,
      () => {
        e == null || e.setPath(a.value);
      },
      { deep: !0 }
    ), v(
      () => u.endArrow,
      () => {
        e == null || e.setMap(null), i !== void 0 && k(i.value);
      }
    ), v(
      [() => u.strokeWeight, () => u.strokeColor, () => u.strokeOpacity, () => u.strokeStyle],
      ([r, m, t, l]) => {
        e == null || e.setOptions({
          strokeWeight: r,
          strokeColor: m,
          strokeOpacity: t,
          strokeStyle: l
        });
      }
    ), v(
      () => u.zIndex,
      (r) => {
        r !== void 0 && (e == null || e.setZIndex(r));
      }
    ), P(() => {
      e == null || e.setMap(null);
    }), (r, m) => (g(), y("div", null, [
      _(r.$slots, "default")
    ]));
  }
}), U = { key: 0 }, V = { key: 1 }, q = /* @__PURE__ */ C({
  __name: "KakaoMapMarkerPolyline",
  props: {
    markerList: {},
    endArrow: { type: Boolean },
    strokeWeight: {},
    strokeColor: {},
    strokeOpacity: {},
    strokeStyle: {},
    zIndex: {},
    showMarkerOrder: { type: Boolean }
  },
  setup(p) {
    const u = p, i = O("mapRef"), e = h([]), a = (t) => {
      e.value.push(t);
    }, k = (t) => {
      const l = e.value.indexOf(t);
      e.value.splice(l, 1);
    }, r = (t) => {
      const l = u.markerList, o = e.value.indexOf(t);
      l[o].lat = t.getPosition().getLat(), l[o].lng = t.getPosition().getLng();
    }, m = (t, l) => `<div style="position:relative; bottom:${l}">
        ${t}
      </div>`;
    return (t, l) => (g(), y(K, null, [
      u.markerList && b(i) !== null ? (g(), y("div", U, [
        (g(!0), y(K, null, I(u.markerList, (o, d) => (g(), w(b($), {
          id: d,
          key: o.key === void 0 ? d : o.key,
          map: b(i),
          lat: o.lat,
          lng: o.lng,
          draggable: o.draggable,
          image: o.image,
          onOnLoadKakaoMapMarker: a,
          onDragEndKakaoMapMarker: r,
          onDeleteKakaoMapMarker: k
        }, null, 8, ["id", "map", "lat", "lng", "draggable", "image"]))), 128)),
        (g(!0), y(K, null, I(u.markerList, (o, d) => (g(), y("div", { key: d }, [
          d !== u.markerList.length - 1 ? (g(), w(b(E), {
            key: 0,
            latLngList: [
              { lat: u.markerList[d].lat, lng: u.markerList[d].lng },
              { lat: u.markerList[d + 1].lat, lng: u.markerList[d + 1].lng }
            ],
            endArrow: u.endArrow,
            strokeWeight: u.strokeWeight,
            strokeColor: u.strokeColor,
            strokeOpacity: u.strokeOpacity,
            strokeStyle: u.strokeStyle,
            zIndex: u.zIndex
          }, null, 8, ["latLngList", "endArrow", "strokeWeight", "strokeColor", "strokeOpacity", "strokeStyle", "zIndex"])) : L("", !0)
        ]))), 128))
      ])) : L("", !0),
      u.markerList && u.showMarkerOrder ? (g(), y("div", V, [
        (g(!0), y(K, null, I(u.markerList, (o, d) => (g(), w(b(x), {
          key: d,
          lat: o.lat,
          lng: o.lng,
          "y-anchor": 0,
          content: m(o.order !== void 0 ? o.order : d, o.orderBottomMargin)
        }, null, 8, ["lat", "lng", "content"]))), 128))
      ])) : L("", !0),
      _(t.$slots, "default")
    ], 64));
  }
}), X = {
  install: (p) => {
    p.component("KakaoMap", T), p.component("KakaoMapMarker", $), p.component("KakaoMapCustomOverlay", x), p.component("KakaoMapInfoWindow", B), p.component("KakaoMapMarkerPolyline", q), p.component("KakaoMapPolyline", E);
  }
};
export {
  T as KakaoMap,
  x as KakaoMapCustomOverlay,
  B as KakaoMapInfoWindow,
  $ as KakaoMapMarker,
  q as KakaoMapMarkerPolyline,
  E as KakaoMapPolyline,
  X as Vue3KakaoMaps,
  M as isKakaoMapApiLoaded,
  Q as useKakao
};
